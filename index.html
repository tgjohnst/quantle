<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale-1.0">
    <title>Quantum Wordle - JSON Loaded</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; 
        }
        .tile {
            width: 60px; height: 60px; border: 2px solid #d1d5db; 
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; font-weight: bold; text-transform: uppercase;
            margin: 2px; border-radius: 0.375rem;
            transition: transform 0.2s ease-in-out, background-color 0.3s ease, border-color 0.3s ease;
        }
        .potential-tile {
            width: 60px; min-height: 50px; border: 2px solid #9ca3af;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 0.7rem; font-weight: normal; text-transform: uppercase;
            margin: 2px; padding: 4px; border-radius: 0.375rem;
            background-color: #f3f4f6; line-height: 1.1;
            overflow-wrap: break-word; word-break: break-all;
        }
        .potential-tile.collapsed { font-size: 1.5rem; font-weight: bold; }
        .potential-tile.correct-implicit { background-color: #d1fae5; border-color: #10b981; }
        .key {
            height: 50px; min-width: 30px; padding: 0 10px; border: 1px solid #9ca3af;
            display: flex; justify-content: center; align-items: center;
            font-size: 1rem; font-weight: bold; text-transform: uppercase;
            border-radius: 0.375rem; cursor: pointer; background-color: #e5e7eb;
            transition: background-color 0.2s ease;
        }
        .key:hover:not(:disabled) { background-color: #d1d5db; }
        .key:disabled { opacity: 0.6; cursor: not-allowed; }
        .key.wide { min-width: 60px; }
        .tile.green, .key.green { background-color: #10b981; border-color: #059669; color: white; }
        .tile.yellow, .key.yellow { background-color: #f59e0b; border-color: #d97706; color: white; }
        .tile.grey, .key.grey { background-color: #6b7280; border-color: #4b5563; color: white; }
        .tile.pop { animation: pop 0.1s ease-in-out; }
        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .tile.flip { animation: flip 0.5s ease forwards; }
        @keyframes flip { 0% { transform: rotateX(0deg); } 50% { transform: rotateX(90deg); } 100% { transform: rotateX(0deg); } }
        #toast {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 10px 20px; background-color: rgba(0,0,0,0.7); color: white;
            border-radius: 8px; z-index: 1000; opacity: 0;
            transition: opacity 0.5s ease-in-out; pointer-events: none;
        }
        #toast.show { opacity: 1; }
        #loading-indicator {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px; background-color: rgba(255,255,255,0.9); border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2); z-index: 3000;
            font-size: 1.2rem; color: #374151; display: none; /* Hidden by default */
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="toast"></div>
    <div id="loading-indicator">Loading Quantum Word Lists...</div>

    <header class="mb-4 sm:mb-6 text-center">
        <h1 class="text-3xl sm:text-4xl font-bold text-gray-800">Quantum Wordle</h1>
        <p class="text-sm text-gray-600">Uncover the word by collapsing quantum states!</p>
    </header>

    <div id="potential-state-display" class="flex justify-center mb-3 sm:mb-4"></div>
    <div id="guess-grid" class="grid grid-rows-6 gap-1 mb-4 sm:mb-6"></div>
    <div id="keyboard" class="flex flex-col items-center space-y-1 sm:space-y-2"></div>
    <button id="newGameButton" class="mt-6 px-6 py-3 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition duration-150 ease-in-out" disabled>New Game</button>

    <script>
        // --- SIMULATED JSON FILE CONTENT ---
        // In a real app, you would fetch these from actual .json files.
        const solutionsJSONString = `
            ["APPLE", "BEACH", "CHAIR", "DREAM", "EAGLE", "FANCY", "GHOST", "HEART", 
             "INPUT", "JOLLY", "KNOCK", "LEMON", "MANGO", "NIGHT", "OCEAN", "PAINT", 
             "QUEEN", "RIVER", "SNAKE", "TABLE", "UNITY", "VOICE", "WATCH", "XENON", 
             "YACHT", "ZEBRA"]
        `;
        const allowedGuessesJSONString = `
            ["APPLE", "BEACH", "CHAIR", "DREAM", "EAGLE", "FANCY", "GHOST", "HEART", 
             "INPUT", "JOLLY", "KNOCK", "LEMON", "MANGO", "NIGHT", "OCEAN", "PAINT", 
             "QUEEN", "RIVER", "SNAKE", "TABLE", "UNITY", "VOICE", "WATCH", "XENON", 
             "YACHT", "ZEBRA", "ABACK", "ABASE", "ABATE", "ABBEY", "ACUTE", "ADMIT", 
             "ADOBE", "ADOPT", "ADORE", "ADULT", "AGENT", "AGILE", "AGREE", "AISLE", 
             "ALBUM", "ALERT", "ALIEN", "ALIGN", "ALIKE", "ALIVE", "ALLOW", "ALONE", 
             "ALOOF", "ALPHA", "ALTAR", "ALTER", "AMASS", "AMBER", "AMEND", "AMPLE", 
             "ANGEL", "ANGER", "ANGLE", "ANKLE", "APART", "APPLY", "APRON", "AUDIO", 
             "AWFUL", "BADGE", "BASIC", "BATON", "BEARD", "BEAST", "BEGAN", "BEING", 
             "BELOW", "BENCH", "BERRY", "BIRCH", "BIRTH", "BLAME", "BLANK", "BLAZE", 
             "BLEAK", "BLEND", "BLESS", "BLIND", "BLINK", "BLISS", "BLOCK", "BLOOD", 
             "BLOOM", "BLOWN", "BLUSH", "BOARD", "BOAST", "BONUS", "BOOST", "BRAID", 
             "BRAKE", "BRAND", "BRAVE", "BREAD", "BREAK", "BREED", "BRIAR", "BRICK", 
             "BRIDE", "BRIEF", "BRING", "BRISK", "BROAD", "BROKE", "BROOK", "BROOM", 
             "BRUSH", "BUILD", "BUILT", "BULKY", "BUNCH", "BURST", "CABIN", "CABLE", 
             "CAMEL", "CANAL", "CANDY", "CANOE", "CARGO", "CAROL", "CARRY", "CATCH", 
             "CEDAR", "CHARM", "CHART", "CHEAT", "CHEEK", "CHEER", "CHEST", "CHIEF", 
             "CHILD", "CHILL", "CHOIR", "CHUNK", "CIVIC", "CIVIL", "CLAIM", "CLAMP", 
             "CLASH", "CLASS", "CLEAN", "CLEAR", "CLERK", "CLICK", "CLIFF", "CLIMB", 
             "CLOCK", "CLOSE", "CLOTH", "CLOUD", "CLOWN", "COACH", "COAST", "CORAL", 
             "COUNT", "COURT", "COVER", "CRACK", "CRAFT", "CRANE", "CRANK", "CRASH", 
             "CREAM", "CREEK", "CREEP", "CREPT", "CREST", "CRISP", "CROSS", "CROWD", 
             "CROWN", "CRUMB", "CRUSH", "CRUST", "CURVE", "CYCLE", "DAILY", "DANCE", 
             "DEALT", "DEATH", "DECAY", "DELAY", "DELTA", "DEPTH", "DEVIL", "DIARY", 
             "DINER", "DIRTY", "DOZEN", "DRAFT", "DRAIN", "DRAWN", "DRIFT", "DRILL", 
             "DRINK", "DRIVE", "DROVE", "DROWN", "DRUNK", "DUTCH", "DWARF", "EAGER", 
             "EARLY", "EARTH", "EIGHT", "ELBOW", "ELDER", "ELECT", "EMPTY", "ENJOY", 
             "ENTER", "ENTRY", "EPOCH", "EQUAL", "ERROR", "ESSAY", "EVENT", "EVERY", 
             "EXACT", "EXCEL", "EXIST", "EXTRA", "FACET", "FAINT", "FAIRY", "FAITH", 
             "FALSE", "FARCE", "FAULT", "FAVOR", "FEAST", "FENCE", "FERRY", "FEVER", 
             "FIELD", "FIERY", "FIFTH", "FIFTY", "FIGHT", "FILLY", "FINAL", "FIRST", 
             "FIXER", "FLACK", "FLAIL", "FLAIR", "FLAKE", "FLAME", "FLANK", "FLARE", 
             "FLASH", "FLASK", "FLECK", "FLEET", "FLESH", "FLICK", "FLIER", "FLING", 
             "FLINT", "FLIRT", "FLOAT", "FLOCK", "FLOOD", "FLOOR", "FLORA", "FLOSS", 
             "FLOUR", "FLOWN", "FLUFF", "FLUID", "FLUNG", "FLUSH", "FOAMY", "FOCUS", 
             "FOGGY", "FORCE", "FORGE", "FORGO", "FORTH", "FORTY", "FORUM", "FOUND", 
             "FRAME", "FRANK", "FRAUD", "FREAK", "FREED", "FREER", "FRESH", "FRIAR", 
             "FRIED", "FROCK", "FROND", "FRONT", "FROST", "FROTH", "FROZE", "FRUIT", 
             "FUNGI", "FUNNY", "GAUZE", "GENRE", "GIANT", "GLASS", "GLAZE", "GLOBE", 
             "GLOOM", "GLORY", "GLOVE", "GRACE", "GRADE", "GRAIN", "GRAND", "GRANT", 
             "GRASP", "GRASS", "GRAVE", "GRAVY", "GREAT", "GREET", "GRIEF", "GRILL", 
             "GRIND", "GRIPE", "GROAN", "GROIN", "GROOM", "GROUP", "GROUT", "GROVE", 
             "GROWL", "GROWN", "GUARD", "GUESS", "GUEST", "GUIDE", "GUILD", "GUILE", 
             "GUILT", "GULLY", "HABIT", "HAIRY", "HAPPY", "HARSH", "HASTE", "HAUNT", 
             "HAVOC", "HAZEL", "HEADY", "HEAVY", "HENCE", "HINGE", "HOBBY", "HOIST", 
             "HONEY", "HONOR", "HORDE", "HORSE", "HOTEL", "HUMAN", "HUMID", "HUMOR", 
             "HURRY", "IDEAL", "IMAGE", "IMPLY", "INDEX", "INNER", "IRONY", "ISSUE", 
             "IVORY", "JAUNT", "JAZZY", "JOINT", "JUDGE", "JUICE", "JUICY", "JUMBO", 
             "JUROR", "KARMA", "KAYAK", "KEBAB", "KHAKI", "KIOSK", "KNEEL", "KNELT", 
             "KNIFE", "LABEL", "LABOR", "LARGE", "LASER", "LATCH", "LATER", "LATTE", 
             "LAUGH", "LAYER", "LEAPT", "LEARN", "LEASE", "LEAST", "LEAVE", "LEDGE", 
             "LEFTY", "LEGAL", "LEVEL", "LEVER", "LIBEL", "LIEGE", "LILAC", "LIMIT", 
             "LINEN", "LINER", "LINGO", "LITER", "LITHE", "LIVER", "LIVID", "LLAMA", 
             "LOCAL", "LOCUS", "LODGE", "LOFTY", "LOGIC", "LOOPY", "LORRY", "LOSER", 
             "LOUSE", "LOVER", "LOWER", "LOWLY", "LOYAL", "LUCID", "LUCKY", "LUMPY", 
             "LUNAR", "LUNCH", "LURID", "LUSSH", "LYRIC", "MACAW", "MADAM", "MAGIC", 
             "MAJOR", "MAKER", "MAPLE", "MARCH", "MARRY", "MARSH", "MASON", "MASSY", 
             "MATCH", "MAYBE", "MAYOR", "MEALY", "MEANT", "MEATY", "MEDAL", "MEDIA", 
             "MERGE", "MERIT", "MERRY", "METAL", "METER", "METRO", "MIDST", "MIGHT", 
             "MINOR", "MINUS", "MODEL", "MOIST", "MOLAR", "MONEY", "MONTH", "MOODY", 
             "MORAL", "MOTEL", "MOTOR", "MOTTO", "MOUNT", "MOURN", "MOVIE", "MUCKY", 
             "MUMMY", "MUSIC", "NAIVE", "NANNY", "NASTY", "NAVAL", "NEEDY", "NERVE", 
             "NEWER", "NICHE", "NIECE", "NINJA", "NINTH", "NOBLE", "NOISE", "NOISY", 
             "NORTH", "NOTCH", "NOVEL", "NYMPH", "OASIS", "OCCUR", "OFFER", "OFTEN", 
             "OLDEN", "OLDER", "ONION", "ONSET", "OPERA", "OPTIC", "ORBIT", "ORDER", 
             "ORGAN", "OTHER", "OUGHT", "OUTDO", "OUTER", "OVERT", "OWNER", "OXIDE", 
             "OZONE", "PACER", "PADDY", "PAGAN", "PANEL", "PANIC", "PAPER", "PARKA", 
             "PARTY", "PASTA", "PASTE", "PASTY", "PATCH", "PATIO", "PAUSE", "PEACE", 
             "PEACH", "PEARL", "PEDAL", "PENAL", "PENNY", "PERCH", "PERIL", "PETAL", 
             "PETTY", "PHASE", "PHONE", "PHOTO", "PIANO", "PICKY", "PIETY", "PILOT", 
             "PINCH", "PINEY", "PINKY", "PINTO", "PIPER", "PIQUE", "PITCH", "PIXEL", 
             "PIZZA", "PLACE", "PLAID", "PLAIN", "PLAIT", "PLANE", "PLANK", "PLANT", 
             "PLATE", "PLAZA", "PLEAD", "PLEAT", "PLUCK", "PLUMB", "PLUME", "PLUMP", 
             "PLUSH", "POESY", "POINT", "POISE", "POKER", "POLAR", "POLKA", "POUCH", 
             "POUND", "POWER", "PRESS", "PRICE", "PRICK", "PRIDE", "PRIME", "PRINT", 
             "PRIOR", "PRIZE", "PROBE", "PRONE", "PROOF", "PROUD", "PROVE", "PROWL", 
             "PROXY", "PRUDE", "PRUNE", "PSALM", "PULPY", "PUNCH", "PUPIL", "PUPPY", 
             "PURGE", "QUACK", "QUAIL", "QUAKE", "QUALM", "QUART", "QUASH", "QUERY", 
             "QUEST", "QUEUE", "QUICK", "QUIET", "QUILL", "QUIRK", "QUITE", "QUOTA", 
             "QUOTE", "RABBI", "RADAR", "RADIO", "RAINY", "RAISE", "RALLY", "RAMEN", 
             "RANCH", "RANDY", "RANGE", "RAPID", "RATIO", "RAVEN", "RAYON", "RAZOR", 
             "REACH", "REACT", "READY", "REALM", "REBEL", "REBUT", "RECAP", "REGAL", 
             "REIGN", "RELAX", "RELAY", "RELIC", "RENEW", "REPAY", "REPEL", "REPLY", 
             "RESET", "RESIN", "RETCH", "RETRY", "REVEL", "REVUE", "RHYME", "RIDER", 
             "RIFLE", "RIGHT", "RIGID", "RIGOR", "RINSE", "RIPEN", "RISEN", "RISER", 
             "RISKY", "RIVAL", "ROCKY", "RODEO", "ROGER", "ROOMY", "ROOST", "ROTOR", 
             "ROUGH", "ROUND", "ROUSE", "ROUTE", "ROVER", "ROYAL", "RUDDY", "RUDER", 
             "RUGBY", "RULER", "RUMBA", "RUMOR", "RURAL", "RUSTY", "SABLE", "SADLY", 
             "SAFER", "SAINT", "SALAD", "SALON", "SALSA", "SALTY", "SALVE", "SALVO", 
             "SANDY", "SATIN", "SAUTE", "SAVOR", "SCALD", "SCALE", "SCALP", "SCALY", 
             "SCAMP", "SCANT", "SCARE", "SCARF", "SCARY", "SCENE", "SCENT", "SCOLD", 
             "SCOPE", "SCORE", "SCORN", "SCOUR", "SCOUT", "SCOWL", "SCRAM", "SCRAP", 
             "SCREE", "SCREW", "SCRUB", "SCUBA", "SCUFF", "SEDAN", "SEEDY", "SEIZE", 
             "SENSE", "SERUM", "SERVE", "SETUP", "SEVEN", "SEVER", "SEWER", "SHACK", 
             "SHADE", "SHADY", "SHAFT", "SHAKE", "SHAKY", "SHALE", "SHALL", "SHAME", 
             "SHANK", "SHAPE", "SHARE", "SHARK", "SHARP", "SHAVE", "SHAWL", "SHEAR", 
             "SHEEN", "SHEEP", "SHEER", "SHEET", "SHEIK", "SHELF", "SHELL", "SHIFT", 
             "SHINE", "SHINY", "SHIRE", "SHIRK", "SHIRT", "SHOCK", "SHONE", "SHOOK", 
             "SHOOT", "SHORE", "SHORN", "SHORT", "SHOUT", "SHOVE", "SHOWN", "SHOWY", 
             "SHRED", "SHREW", "SHRUB", "SHRUG", "SHUCK", "SHUNT", "SHUSH", "SHYLY", 
             "SIEGE", "SIGHT", "SIGMA", "SILKY", "SILLY", "SINCE", "SINEW", "SINGE", 
             "SIREN", "SIXTH", "SIXTY", "SKATE", "SKEPT", "SKIER", "SKIFF", "SKILL", 
             "SKIMP", "SKIRT", "SKULK", "SKULL", "SKUNK", "SLACK", "SLAIN", "SLANG", 
             "SLANT", "SLASH", "SLATE", "SLAVE", "SLEEK", "SLEEP", "SLEET", "SLEPT", 
             "SLICE", "SLICK", "SLIDE", "SLIME", "SLIMY", "SLING", "SLINK", "SLOPE", 
             "SLOSH", "SLOTH", "SLUMP", "SLUNG", "SLUNK", "SLURP", "SLUSH", "SMALL", 
             "SMART", "SMASH", "SMEAR", "SMELL", "SMELT", "SMILE", "SMIRK", "SMITE", 
             "SMITH", "SMOCK", "SMOKE", "SMOKY", "SMOTE", "SNACK", "SNAIL", "SNARE", 
             "SNARL", "SNEAK", "SNEER", "SNIDE", "SNIFF", "SNIPE", "SNOOP", "SNORE", 
             "SNORT", "SNOUT", "SNOWY", "SNUCK", "SNUFF", "SOAPY", "SOBER", "SOLAR", 
             "SOLID", "SOLVE", "SONAR", "SONIC", "SOOTH", "SOOTY", "SORRY", "SOUND", 
             "SOUTH", "SOWER", "SPACE", "SPADE", "SPANK", "SPARE", "SPARK", "SPASM", 
             "SPATE", "SPAWN", "SPEAK", "SPEAR", "SPECK", "SPEED", "SPELL", "SPELT", 
             "SPEND", "SPENT", "SPICE", "SPICY", "SPIED", "SPIEL", "SPIKE", "SPIKY", 
             "SPILL", "SPILT", "SPINE", "SPINY", "SPIRE", "SPITE", "SPLASH", "SPLAT", 
             "SPLIT", "SPOIL", "SPOKE", "SPOOF", "SPOOK", "SPOOL", "SPOON", "SPORE", 
             "SPORT", "SPOTS", "SPOUT", "SPRAY", "SPREE", "SPRIG", "SPUNK", "SPURN", 
             "SPURT", "SQUAD", "SQUAT", "SQUIB", "STACK", "STAFF", "STAGE", "STAID", 
             "STAIN", "STAIR", "STAKE", "STALE", "STALK", "STALL", "STAMP", "STAND", 
             "STANK", "STARE", "STARK", "START", "STATE", "STAVE", "STEAD", "STEAK", 
             "STEAL", "STEAM", "STEED", "STEEL", "STEEP", "STEER", "STEIN", "STERN", 
             "STICK", "STIFF", "STILL", "STILT", "STING", "STINK", "STINT", "STIRP", 
             "STOCK", "STOIC", "STOKE", "STOLE", "STOMP", "STONE", "STONY", "STOOD", 
             "STOOL", "STOOP", "STORE", "STORK", "STORM", "STORY", "STOUT", "STOVE", 
             "STRAP", "STRAW", "STRAY", "STREP", "STRIP", "STRUT", "STUCK", "STUDY", 
             "STUFF", "STUMP", "STUNG", "STUNK", "STYLE", "SUAVE", "SUGAR", "SUING", 
             "SUITE", "SULKY", "SUNNY", "SUPER", "SURER", "SURGE", "SWAMI", "SWAMP", 
             "SWARM", "SWASH", "SWATH", "SWEAR", "SWEAT", "SWEEP", "SWEET", "SWELL", 
             "SWEPT", "SWIFT", "SWILL", "SWINE", "SWING", "SWIRL", "SWISH", "SWOON", 
             "SWOOP", "SWORD", "SWORE", "SWORN", "SWUNG", "SYNOD", "SYRUP", "TAFFY", 
             "TAKEN", "TALON", "TAMER", "TANGO", "TANGY", "TAPER", "TAPIR", "TARDY", 
             "TAROT", "TASTE", "TASTY", "TAUNT", "TAWNY", "TEACH", "TEARY", "TEASE", 
             "TEMPO", "TENSE", "TENTH", "TEPEE", "TEPID", "TERSE", "THANK", "THEFT", 
             "THEIR", "THEME", "THERE", "THESE", "THICK", "THIEF", "THIGH", "THING", 
             "THINK", "THIRD", "THORN", "THOSE", "THREE", "THROW", "THRUM", "THUMB", 
             "THUMP", "THYME", "TIDAL", "TIDDY", "TIGER", "TIGHT", "TILDE", "TIMER", 
             "TIMID", "TINGE", "TINNY", "TIPSY", "TITAN", "TITLE", "TOAST", "TODAY", 
             "TOKEN", "TONAL", "TONGA", "TONIC", "TOPAZ", "TOPIC", "TORCH", "TORSO", 
             "TORUS", "TOTAL", "TOUCH", "TOUGH", "TOWEL", "TOWER", "TOXIC", "TOXIN", 
             "TRACE", "TRACK", "TRACT", "TRADE", "TRAIL", "TRAIN", "TRAIT", "TRASH", 
             "TRAWL", "TREAD", "TREAT", "TREND", "TRIAD", "TRIAL", "TRIBE", "TRICE", 
             "TRICK", "TRIED", "TRIPE", "TRITE", "TROLL", "TROOP", "TROPE", "TROUT", 
             "TROVE", "TRUCE", "TRUCK", "TRUER", "TRULY", "TRUMP", "TRUNK", "TRUSS", 
             "TRUST", "TRUTH", "TRYST", "TUBAL", "TUBER", "TULIP", "TULLE", "TUMOR", 
             "TUNIC", "TURBO", "TUTOR", "TWANG", "TWEAK", "TWEED", "TWEET", "TWICE", 
             "TWINE", "TWIRL", "TWIST", "TYING", "ULCER", "ULTRA", "UMBRA", "UNDER", 
             "UNDUE", "UNFED", "UNFIT", "UNIFY", "UNION", "UNITE", "UNLIT", "UNMET", 
             "UNTIE", "UNTIL", "UNWED", "UNZIP", "UPPER", "UPSET", "URBAN", "USAGE", 
             "USHER", "USING", "USUAL", "USURP", "UTTER", "VACUO", "VAGUE", "VALET", 
             "VALID", "VALOR", "VALUE", "VALVE", "VAPID", "VAPOR", "VAULT", "VAUNT", 
             "VEGAN", "VENOM", "VENUE", "VERGE", "VERSE", "VERSO", "VERVE", "VICAR", 
             "VIDEO", "VIGOR", "VILLA", "VINYL", "VIPER", "VIRAL", "VISIT", "VISOR", 
             "VISTA", "VITAL", "VIVID", "VIXEN", "VOCAL", "VODKA", "VOGUE", "VALID", 
             "WACKY", "WADER", "WAGER", "WAGON", "WAIST", "WAIVE", "WAKEN", "WALTZ", 
             "WASTE", "WATER", "WAVER", "WAXEN", "WEARY", "WEAVE", "WEDGE", "WEEDY", 
             "WEIGH", "WEIRD", "WELCH", "WELSH", "WHACK", "WHARF", "WHEAT", "WHEEL", 
             "WHELP", "WHERE", "WHICH", "WHIFF", "WHILE", "WHINE", "WHINY", "WHIRL", 
             "WHISK", "WHITE", "WHOLE", "WHOOP", "WHOSE", "WIDEN", "WIDER", "WIDOW", 
             "WIDTH", "WIELD", "WIGHT", "WILLY", "WIMPY", "WINCE", "WINCH", "WINDY", 
             "WIPER", "WISDM", "WISER", "WISPY", "WITCH", "WITTY", "WOMAN", "WOMEN", 
             "WORLD", "WORRY", "WORSE", "WORST", "WORTH", "WOULD", "WOUND", "WOVEN", 
             "WRACK", "WRATH", "WREAK", "WRECK", "WREST", "WRING", "WRIST", "WRITE", 
             "WRONG", "WROTE", "WRUNG", "WRYLY", "YEARN", "YIELD", "YODEL", "YOKEL", 
             "YOUNG", "YOUTH", "ZESTY"]
        `;
        // --- END SIMULATED JSON ---

        const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
        const WORD_LENGTH = 5;
        const MAX_GUESSES = 6;
        const POTENTIALS_PER_SLOT = 4;

        let solutionWords = [];
        let allowedGuessWordsSet = new Set();
        let gameReady = false;

        let targetWord = '';
        let globalPotentials = [];
        let guesses = [];
        let currentRow = 0;
        let currentCol = 0;
        let isGameOver = false;
        let keyboardKeyStates = {};

        const guessGridElement = document.getElementById('guess-grid');
        const potentialStateDisplayElement = document.getElementById('potential-state-display');
        const keyboardElement = document.getElementById('keyboard');
        const newGameButton = document.getElementById('newGameButton');
        const toastElement = document.getElementById('toast');
        const loadingIndicator = document.getElementById('loading-indicator');

        function showToast(message, duration = 3000) {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), duration);
        }

        function setKeyboardDisabled(disabled) {
            document.querySelectorAll('.key').forEach(key => key.disabled = disabled);
        }
        
        async function setupGameEnvironment() {
            loadingIndicator.style.display = 'block';
            newGameButton.disabled = true;
            setKeyboardDisabled(true);

            // Simulate fetching and parsing JSON files
            // In a real app, use actual fetch() calls here
            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate network delay

            try {
                solutionWords = JSON.parse(solutionsJSONString);
                const allowedGuessesArray = JSON.parse(allowedGuessesJSONString);
                allowedGuessWordsSet = new Set(allowedGuessesArray.map(word => word.toUpperCase()));

                if (!solutionWords.length || !allowedGuessWordsSet.size) {
                    throw new Error("Word lists are empty or failed to load.");
                }
                gameReady = true;
                console.log("Word lists loaded successfully.");
            } catch (error) {
                console.error("Error loading word lists:", error);
                showToast("Error: Could not load word lists. Please refresh.", 10000);
                loadingIndicator.textContent = "Error loading game data!";
                // Game cannot start, so we don't enable buttons or call initializeGame
                return; 
            }
            
            loadingIndicator.style.display = 'none';
            newGameButton.disabled = false;
            setKeyboardDisabled(false);
            initializeGame(); // Start the first game
        }


        function initializeGame() {
            if (!gameReady) {
                showToast("Game data not ready. Please wait or refresh.", 5000);
                // Attempt to re-setup if not ready, though setupGameEnvironment should handle the first call.
                // This is more of a safeguard for direct calls to initializeGame.
                if (!solutionWords.length) { // A simple check if setup hasn't run or failed.
                     console.warn("InitializeGame called but game not ready. Attempting setup.");
                     setupGameEnvironment(); // This might lead to nested calls if not careful.
                     return;
                }
            }

            targetWord = solutionWords[Math.floor(Math.random() * solutionWords.length)].toUpperCase();
            console.log("Target Word (for debugging):", targetWord);

            globalPotentials = [];
            for (let i = 0; i < WORD_LENGTH; i++) {
                const correctLetter = targetWord[i];
                let slotPotentials = [correctLetter];
                let tempAlphabet = ALPHABET.filter(l => l !== correctLetter);
                for (let j = tempAlphabet.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [tempAlphabet[j], tempAlphabet[k]] = [tempAlphabet[k], tempAlphabet[j]];
                }
                for (let j = 0; j < POTENTIALS_PER_SLOT - 1 && j < tempAlphabet.length; j++) {
                    slotPotentials.push(tempAlphabet[j]);
                }
                for (let j = slotPotentials.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [slotPotentials[j], slotPotentials[k]] = [slotPotentials[k], slotPotentials[j]];
                }
                globalPotentials.push(slotPotentials);
            }

            guesses = [];
            currentRow = 0;
            currentCol = 0;
            isGameOver = false;
            keyboardKeyStates = {};

            renderPotentialStateDisplay();
            renderGuessGrid();
            renderKeyboard(); // Ensure keyboard is rendered and enabled/disabled state is correct
            setKeyboardDisabled(false); // Explicitly enable keyboard for new game
            newGameButton.disabled = false;
        }

        function renderPotentialStateDisplay() {
            potentialStateDisplayElement.innerHTML = '';
            globalPotentials.forEach((potentials, index) => {
                const tile = document.createElement('div');
                tile.classList.add('potential-tile');
                tile.textContent = potentials.join(','); 
                if (potentials.length === 1) {
                    tile.classList.add('collapsed');
                    if (potentials[0] === targetWord[index]) {
                         tile.classList.add('correct-implicit');
                    }
                }
                potentialStateDisplayElement.appendChild(tile);
            });
        }

        function renderGuessGrid() {
            guessGridElement.innerHTML = '';
            for (let i = 0; i < MAX_GUESSES; i++) {
                const rowElement = document.createElement('div');
                rowElement.classList.add('flex', 'justify-center');
                for (let j = 0; j < WORD_LENGTH; j++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.id = `tile-${i}-${j}`;
                    const guessData = guesses[i];
                    if (guessData && guessData.word[j]) {
                        tile.textContent = guessData.word[j];
                        if (guessData.feedback) {
                           const color = guessData.feedback[j];
                           if (color === 'green') tile.classList.add('green');
                           else if (color === 'yellow') tile.classList.add('yellow');
                           else if (color === 'grey') tile.classList.add('grey');
                        }
                    }
                    rowElement.appendChild(tile);
                }
                guessGridElement.appendChild(rowElement);
            }
        }
        
        function renderKeyboard() {
            keyboardElement.innerHTML = '';
            const layout = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];
            layout.forEach((row, rowIndex) => {
                const rowElement = document.createElement('div');
                rowElement.classList.add('flex', 'justify-center', 'space-x-1', 'sm:space-x-2');
                if (rowIndex === layout.length - 1) {
                    const enterKey = createKey('ENTER', true);
                    rowElement.appendChild(enterKey);
                }
                row.split('').forEach(char => rowElement.appendChild(createKey(char)));
                if (rowIndex === layout.length - 1) {
                    const backspaceKey = createKey('⌫', true);
                    rowElement.appendChild(backspaceKey);
                }
                keyboardElement.appendChild(rowElement);
            });
            updateKeyboardColors();
        }

        function createKey(char, isWide = false) {
            const keyElement = document.createElement('button');
            keyElement.classList.add('key');
            if (isWide) keyElement.classList.add('wide');
            keyElement.textContent = char;
            keyElement.dataset.key = char;
            keyElement.addEventListener('click', () => handleKeyPress(char));
            return keyElement;
        }
        
        function updateKeyboardColors() {
            document.querySelectorAll('.key').forEach(keyEl => {
                const char = keyEl.dataset.key;
                keyEl.classList.remove('green', 'yellow', 'grey');
                if (keyboardKeyStates[char]) {
                    keyEl.classList.add(keyboardKeyStates[char]);
                }
            });
        }

        function handleKeyPress(key) {
            if (isGameOver || !gameReady) return;

            if (key === 'ENTER') {
                if (currentCol === WORD_LENGTH) submitGuess();
                else showToast("Not enough letters");
            } else if (key === '⌫' || key === 'BACKSPACE') {
                if (currentCol > 0) {
                    currentCol--;
                    document.getElementById(`tile-${currentRow}-${currentCol}`).textContent = '';
                }
            } else if (ALPHABET.includes(key.toUpperCase()) && currentCol < WORD_LENGTH) {
                const tile = document.getElementById(`tile-${currentRow}-${currentCol}`);
                tile.textContent = key.toUpperCase();
                tile.classList.add('pop'); 
                setTimeout(() => tile.classList.remove('pop'), 100);
                currentCol++;
            }
        }

        function getCurrentGuessWord() {
            let word = "";
            for (let j = 0; j < WORD_LENGTH; j++) word += document.getElementById(`tile-${currentRow}-${j}`).textContent;
            return word;
        }

        async function submitGuess() {
            const guessedWord = getCurrentGuessWord();
            if (guessedWord.length !== WORD_LENGTH) return;

            if (!allowedGuessWordsSet.has(guessedWord.toUpperCase())) {
                showToast("Not in word list");
                // Optionally shake the row or give other visual feedback
                const rowTiles = guessGridElement.children[currentRow].children;
                for (let tile of rowTiles) {
                    tile.classList.add('border-red-500'); // Temporary red border
                }
                setTimeout(() => {
                     for (let tile of rowTiles) {
                        tile.classList.remove('border-red-500');
                     }
                }, 500);
                return;
            }

            const { feedback, newPotentials } = calculateFeedbackAndUpdatePotentials(guessedWord, targetWord, globalPotentials);
            globalPotentials = newPotentials; 
            guesses[currentRow] = { word: guessedWord, feedback: feedback };
            
            const currentRowTiles = guessGridElement.children[currentRow].children;
            for (let i = 0; i < WORD_LENGTH; i++) {
                const tile = currentRowTiles[i];
                tile.classList.add('flip'); 
                await new Promise(resolve => setTimeout(resolve, 120 * i + (i === 0 ? 0 : 50) ));
                const color = feedback[i];
                if (color === 'green') tile.classList.add('green');
                else if (color === 'yellow') tile.classList.add('yellow');
                else if (color === 'grey') tile.classList.add('grey');
                const letter = guessedWord[i];
                const currentColor = keyboardKeyStates[letter];
                if (!currentColor || (currentColor === 'grey' && (color === 'yellow' || color === 'green')) || (currentColor === 'yellow' && color === 'green')) {
                    keyboardKeyStates[letter] = color;
                }
            }
            await new Promise(resolve => setTimeout(resolve, 120 * WORD_LENGTH + 200));

            renderPotentialStateDisplay(); 
            updateKeyboardColors();
            checkWinLoss(guessedWord, feedback);

            if (!isGameOver) {
                currentRow++;
                currentCol = 0;
                if (currentRow === MAX_GUESSES) {
                    isGameOver = true;
                    showToast(`Game Over! The word was ${targetWord}.`, 5000);
                    newGameButton.disabled = false;
                    setKeyboardDisabled(true);
                }
            } else {
                 newGameButton.disabled = false;
                 setKeyboardDisabled(true);
            }
        }

        function calculateFeedbackAndUpdatePotentials(guess, target, currentPotentials) {
            let targetLetters = target.split(''); 
            let guessLetters = guess.split(''); 
            let feedback = Array(WORD_LENGTH).fill('grey'); 
            let newPotentialsCopy = JSON.parse(JSON.stringify(currentPotentials));

            for (let i = 0; i < WORD_LENGTH; i++) { // Greens
                if (guessLetters[i] === targetLetters[i]) {
                    feedback[i] = 'green';
                    newPotentialsCopy[i] = [targetLetters[i]]; 
                    targetLetters[i] = null; 
                    guessLetters[i] = '#'; 
                }
            }
            for (let i = 0; i < WORD_LENGTH; i++) { // Yellows
                if (guessLetters[i] !== '#') {
                    const targetIndex = targetLetters.indexOf(guessLetters[i]);
                    if (targetIndex !== -1) {
                        feedback[i] = 'yellow';
                        targetLetters[targetIndex] = null; 
                        if (newPotentialsCopy[i].length > 1) {
                            const idxInPotential = newPotentialsCopy[i].indexOf(guessLetters[i]);
                            if (idxInPotential > -1) newPotentialsCopy[i].splice(idxInPotential, 1);
                        }
                        guessLetters[i] = '$'; 
                    }
                }
            }
            for (let i = 0; i < WORD_LENGTH; i++) { // Greys update potentials
                const originalGuessedLetter = guess.split('')[i];
                if (feedback[i] === 'grey') { 
                    for (let j = 0; j < WORD_LENGTH; j++) {
                        if (newPotentialsCopy[j].length > 1) {
                            const idxInPotential = newPotentialsCopy[j].indexOf(originalGuessedLetter);
                            if (idxInPotential > -1) newPotentialsCopy[j].splice(idxInPotential, 1);
                        }
                    }
                }
            }
            return { feedback, newPotentials: newPotentialsCopy };
        }

        function checkWinLoss(guessedWord, feedback) {
            if (feedback.every(f => f === 'green')) {
                isGameOver = true;
                showToast("Congratulations! You solved it!", 5000);
                const currentRowTiles = guessGridElement.children[currentRow].children;
                for (let i = 0; i < currentRowTiles.length; i++) setTimeout(() => currentRowTiles[i].classList.add('pop'), i * 100);
                return;
            }
            let allPotentialsCorrectlyCollapsed = true;
            for(let i=0; i<WORD_LENGTH; i++) {
                if(!(globalPotentials[i].length === 1 && globalPotentials[i][0] === targetWord[i])) {
                    allPotentialsCorrectlyCollapsed = false;
                    break;
                }
            }
            if (allPotentialsCorrectlyCollapsed) {
                isGameOver = true;
                potentialStateDisplayElement.childNodes.forEach((tile, index) => {
                    if (globalPotentials[index][0] === targetWord[index]) tile.classList.add('green');
                });
                showToast(`Quantum Collapse! The word was ${targetWord}. You got it!`, 5000);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey || e.altKey) return; 
            if ((isGameOver || !gameReady) && e.key !== 'Enter' && e.key !== 'Backspace') return;
            
            if (e.key === 'Enter') {
                 if (!gameReady) return; // Don't allow enter if game not ready
                 if (isGameOver) { /* newGameButton.click(); // Optionally allow Enter to start new game */ } 
                 else handleKeyPress('ENTER');
            } else if (e.key === 'Backspace') {
                if (!gameReady) return;
                handleKeyPress('⌫');
            } else if (e.key.length === 1 && e.key.match(/[a-z]/i)) {
                if (!gameReady) return;
                handleKeyPress(e.key.toUpperCase());
            }
        });
        
        newGameButton.addEventListener('click', () => {
            if (gameReady) {
                initializeGame();
            } else {
                showToast("Game is still loading, please wait.", 3000);
            }
        });

        // Initial game setup - load words then start
        setupGameEnvironment();
    </script>
</body>
</html>
